Table of Contents
-----------------
-   [Goals](#goals)
    -   [Generating changelog](#changelog)
    -   [Recognizing unimportant commits](#commits)
    -   [Provide more information when browsing the history](#history)
-   [Format of the commit message](#format)
    -   [Revert](#revert)
    -   [Message header](#message-header)
-   [Examples](#examples)


Goals
-------------

### Changelog
We use these three sections in the changelog: new features, bug fixes, improvements.
This list could be generated by the script when doing a release. Along with links to related commits.
Of course, you can edit this change log before the actual release, but it could generate the skeleton.

List of all subjects (first lines in commit message) since last release:
> git log <last tag> HEAD --pretty=format:%s

New features in this release
> git log <last release> HEAD --grep ISSUE


### Commits

These are formatting changes (adding/removing spaces/empty lines, indentation), missing semicolons, comments. So when you are looking for some change, you can ignore these commits - no logic change inside this commit.

When bisecting, you can ignore these by:
> git bisect skip $(git rev-list --grep irrelevant <good place> HEAD)


### History

This would add kinda “context” information.
Look at these messages (taken from last few RocketMQ’s commits):

`Deprecated related core pull consumer classes`

`Polish lite pull consumer and fix bug (#1402)`

`Polish LitePullConsumer (#1395)`

`Deprecated the DefaulteMQPull consumer (#1387)`

`Polish lite pull consumer (#1381)`

All of these messages try to specify where is the change. But they don’t share any convention... Are you able to guess what’s inside? These messages miss place specification... So maybe something like parts of the code: docs, remoting, storage, log, …

I know, you can find this information by checking which files had been changed, but that’s slow. 


Format of the commit message
-------------

### Revert

### Message Header

Examples
-------------



